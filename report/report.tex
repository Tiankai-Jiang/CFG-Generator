\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{commath}
\usepackage{subfig}
\usepackage{float}
\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.5}

\title{ECE653 Project Report}
\author{Tiankai Jiang \and Steven Qin \and Huijie Chu}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\makeatletter
\setlength{\@fptop}{0pt}
\makeatother
\bibliographystyle{ieeetr}
\begin{document}

\maketitle

\begin{abstract}
The main idea of this project is to implement a control graph generator with a foundation build upon the concept of an abstract syntax tree. This report is aimed to help readers better understand the insight of this piece of code with a detailed guild. The introduction session covers a glance at the workflow of this project including a few perspectives on the contribution that the control graph generator may provide. The main part of the algorithms is covered in detail within the implementation session. The project starts off using the python AST package as the parser to identify and parse the input program, which is a piece of read-in code written in python. Processed the code is then stored in the format of an abstract syntax tree, which essentially is an array that contains partitioned statements along with their associated conditions and expressions. The control flow graph is generated by iterate through the processed abstract syntax tree. Graphize is used as the drawing tool to create the final graph representation.
\end{abstract}

\section{Introduction and Overview}\label{section-introduction}
One of the initial purposes of this project is to simplify the time consumption on the preparatory work phase when a new piece of code is handed for understanding. Start by partition a program into an independent or a few aggregated functions. Feed aggregated function bundles respectively into the control graph generator enable readers to visualize the flow of each function, along with their internal logical conditions, statements, and expressions. A control flow graph is a graphical representation that consolidates statements as notation, split and link adjacent notations with edges that each epitomize a path with a correlated logical condition that might be traversed through during the execution phase. It refers to the order in which the individual statements, instructions, or function calls of an imperative or functional program are executed or evaluated.

Furthermore, a comprehensive control graph is essential in the phase of error detection. A missing or contradictory logical condition can create a bug that is laborious to fix. Without a thorough understanding and meticulously go through the logical transition in the program, the bug is arduous to trace. Paths on a control graph, along with their statements, instructions, or function calls, are visually represented. Thus, it is straightforward for a tester to go through suspicious paths without being anxious about getting lost in the flow of logic.

\section{Overview}\label{section-overview}

\section{Purpose}\label{section-purpose}

\section{Encoding of Boolean Cardinality Constraints}\label{section-encoding}
We will present the sequential counter encoding and its advantage over the encoding given in ece650.a4.
\subsection{The Sequential Counter Encoding}
Given $x_1\ldots x_n$, the encoding introduces an extra of $(n-1)*k$ variables, denoted $s_{i,j}$, where $i \in [1,n-1], j\in [1,k]$. The $k$ variables in $s_{i,*}$ represent the number of variables in $x_1\ldots x_n$ that are true in base 1.

Figure 1 shows the sequential counter circuit. Initially, the counter is set to 0. And the circuit will count the number of 1 in $x_1\ldots x_n$. As long as the overflow bit $c_i$ is not 1, $\sum\limits_{i=1}^{n}x_i\leq k$ holds.

Figure 2(a) shows the implementation of the sub-circuit in Figure 1. The sub-circuit takes a number in base 1 from [$s_{i-1,1}$, $s_{i-1,k}$], add $x_i(0\;or\;1)$ and output the results as a number in base 1 to [$s_{i,1}$, $s_{i,k}$]. Figure 2(b) shows a demo when $k=4$. Suppose the input is 2(1100 in unary), and $x_i$ is 1, after the addition, the output will be 3(1110 in unary). If the input is 4(1111) instead, after adding $x_i=1$, the overflow bit $c_i$ is 1 and we will know that the result exceeds 4.

The encoding are as follows:

Since $x_i$ connects directly to an $OR$ gate in each sub-circuit, $s_{i,1}$ must be 1 if $x_i$ is 1.\[\bigwedge\limits_{i=1}^{n-1} \neg x_i \lor s_{i,1}\]

Since there is no input in the first sub-circuit, the output of it is at most 1, which means $s_{1,2}$ to $s_{1,k}$ are guaranteed to be 0.\[\bigwedge\limits_{i=2}^{k} \neg s_{1,i}\]

Since $s_{i-1,j}$ connects directly to an $OR$ gate in each sub-circuit, $s_{i,j}$ must be 1 if $s_{i-1,j}$ is 1.\[\bigwedge\limits_{i=2}^{n-1}\bigwedge\limits_{j=1}^{k}\neg s_{i-1,j} \lor s_{i,j}\]

Since $x_i$ and $s_{i-1,j-1}$ are connected to a $AND$ gate and then the $AND$ gate connects to an $OR$ gate, $s_{i,j}$ must be 1 if $x_i$ and $s_{i-1,j-1}$ are both 1.\[\bigwedge\limits_{i=2}^{n-1}\bigwedge\limits_{j=2}^{k}\neg x_i\lor\neg s_{i-1,j-1} \lor s_{i,j}\]

There should not be any overflow in all n sub-circuits.($i$ starts from 2 because there is no input for the first sub-circuit).\[\bigwedge\limits_{i=2}^{n-1}\neg x_i\lor\neg s_{i-1,k}\]

\end{document}
