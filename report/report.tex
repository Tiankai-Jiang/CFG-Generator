\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{commath}
\usepackage{subfig}
\usepackage{float}
\usepackage{listings}
\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.5}

\title{ECE653 Project Report}
\author{Tiankai Jiang \and Steven Qin \and Huijie Chu}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\makeatletter
\setlength{\@fptop}{0pt}
\makeatother
\bibliographystyle{ieeetr}
\begin{document}

\maketitle

\begin{abstract}
The main idea of this project is to implement a control graph generator with a foundation build upon the concept of an abstract syntax tree. This report is aimed to help readers better understand the insight of this piece of code with a detailed guild. The introduction session covers a glance at the workflow of this project including a few perspectives on the contribution that the control graph generator may provide. The main part of the algorithms is covered in detail within the implementation session. The project starts off using the python AST package as the parser to identify and parse the input program, which is a piece of read-in code written in python. Processed the code is then stored in the format of an abstract syntax tree, which essentially is an array that contains partitioned statements along with their associated conditions and expressions. The control flow graph is generated by iterate through the processed abstract syntax tree. Graphize is used as the drawing tool to create the final graph representation.
\end{abstract}

\section{Introduction and Overview}\label{section-introduction}
One of the initial purposes of this project is to simplify the time consumption on the preparatory work phase when a new piece of code is handed for understanding. Start by partition a program into an independent or a few aggregated functions. Feed aggregated function bundles respectively into the control graph generator enable readers to visualize the flow of each function, along with their internal logical conditions, statements, and expressions. A control flow graph is a graphical representation that consolidates statements as notation, split and link adjacent notations with edges that each epitomize a path with a correlated logical condition that might be traversed through during the execution phase. It refers to the order in which the individual statements, instructions, or function calls of an imperative or functional program are executed or evaluated.

Furthermore, a comprehensive control graph is essential in the phase of error detection. A missing or contradictory logical condition can create a bug that is laborious to fix. Without a thorough understanding and meticulously go through the logical transition in the program, the bug is arduous to trace. Paths on a control graph, along with their statements, instructions, or function calls, are visually represented. Thus, it is straightforward for a tester to go through suspicious paths without being anxious about getting lost in the flow of logic.

\section{Implementation}\label{section-implementation}
\subsection{Preprocessing}
For the purpose of this project, which is to accurately generate a exhaustive control flow graph, there is no point to analyze codes with syntax errors. For the initial set up, the first step is to read and compile the source code. Error code that fails in the preparation step will be returned immediately after.

Most of the informal coding style of the input will not affect the output of ast module since it analyzes the code in a deeper level. As an example. consider the code below.
\begin{lstlisting}
a=1; b = 1; c =\
1
d = [1,
2,
3]
\end{lstlisting}
As shown in the example, the Line separation symbol used above, $\backslash$ or equivalent, may seem to be a strange usage, whereas it does not conduct any syntax error which may prevent compile of the program. The more commonly adapted programming habit is demonstrated below.
\begin{lstlisting}
a = 1
b = 1
c = 1
d = [1, 2, 3]
\end{lstlisting}
In the above example, the spaces between variables and other variables/constants are ignored, the backslash to connect multi-line codes are ignored and the brackets/parentheses that expands multiple lines are ignored. Also, the semicolons that enable multiple statements in one line are omitted. In order words, the compiler does not tend to standardize different programming styles. As long as it successfully passes the compilation. Typos, any symbols or usages from another coding language will be detected and handled as error behavior.

For anothe example, take a look at the code below.
\begin{lstlisting}
a = 1 # this is a comment
\end{lstlisting}
The previous code is identical with the one below.
\begin{lstlisting}
a = 1
\end{lstlisting}

In line comments that immediately follow the code part of the implementation will be read and ignored in the compiler. As an exception, multiline comments(doc strings), which are quoted between a pair of three single or double quotes are not ignored by python interpreter. They are treated as multi-line strings but assigned to any variable for display only. If the source code contains lots of doc strings, the control flow graph will be redundant and confusing. \\
Hence, the second step is to remove the these multiline comments. Using python's tokenize module, we only keep a string token if its previous token is not indentation, is not a new line and the token itself is not the first token in a module. In the context below, standarized input stands for code blocks that can compile without raising any syntax error

\subsection{AST Nodes}
The standardized input source code is then parsed by the python AST module. AST stands for an abstract syntax tree. Therefore, a tree-like structure is generated after parsing, which means the result is either a basic subclass node of ast.AST, e.g. ast.Name, ast.Num, ast.Eq etc., or a recursive structure (an ast node inside a basic subclass node of ast.AST), e.g. ast.Delete( targets = [ast.Name( id='a', ctx=ast.Del() ) ] ). \\
By recursively visiting and processing the parsed result, we can build the control flow graph of the input source code. Since each subclass of ast.AST has its structure/variables, different visiting methods are required. Those methods will be elucidated in the following subsections.

\subsection{Models}
Class BasicBlock is the supermodule that every node in the control flow graph inherits from. Each basic block structure contains a unique block id, two lists of block id to represent the previous and the neighboring block(blocks), a list to store the functions that are called inside the block, and a list to store the statements inside the block.

Each block is assigned with a unique id. To generate unique block id for new blocks and to prevent from using numerous global variables, a singleton class BlockId is used. The singleton class will keep track of every existing blockid and next available block id in case of a new block is generated. Each time a new block id is to generate, the same BlockId instance is called.

Class CFG is the highest level representation of the control flow graph. Every function `def' in the input code will be treated as an individual CFG. The CFG class keeps track of every block in the graph using a dictionary with the format of \textit{blockid $\rightarrow$ basicblock}. It also keeps track of every edge in the graph using a dictionary in the format of \textit{(fromID, toID) $\rightarrow$ condition of the edge}. Finally, it contains another dictionary to keep track of function calls in a function in the format of \textit{function name $\rightarrow$ CFG}.

Class CFGVisiter, which is a subclass from ast.NodeVisitor is the main part of this project. According to the documentation of ast, ast.NodeVisitor is meant to be subclassed and we can define custom visit methods in the subclass. For example, if an ast node is of type \textit{If}, its custom visit method should be defined in method \textit{visit\_If}. All visit functions must follow the conventional function naming style as required for the ast to recognize such function name. In the case, if there does not exist a customized visit method for a certain kind of node, this node will be visited using \textit{generic\_visit} method. Below is the implementation of those custom visiting methods.

\subsection{visit\_*}
Some type of nodes are not that interesting since we know there will not be other control flows inside the node. For example, the node of type augmentation assign, in which the value can only be Name(a += b), Constant(a += 1), Subscript(a += b[0]) or Attributes(a += c.val), will not lead to two or more successors in the CFG. For this kinds of nodes, we only have to add them to the current basic block and then move on. Those type of nodes are not mentioned below.

\subsubsection{Assign}
Normally, the value of ast.Assign class is the same with ast.AugAssign, which means we only have to add it to the current block. For special cases, in which the value is list comprehension, dictionary comprehension, set comprehension, generator expression or lambda expression, we set the corresponding flag and visit those special nodes. So later in the corresponding visit method, e.g. \textit{visit\_ListComp}, we can get certain information from the flag and do some special operation.

\subsubsection{Call}
Except for the special case for lambda expression((lambda x: x+1)(1)), which is treated as a anonymous function call, we append the name of the function being called to a list in class CFG, so later we can show what functions are called in this function.

\subsubsection{For}
For the ast.For class, there will be an arrow(edge) pointing backwards to indicate loop. So, a new block, we called it \textit{h1}, must be added to be the head of that arrow. A \textit{for\_block} is created for the body part of the For statement. And an \textit{after\_for\_block} is created for codes after the For statement. We know that there is an edge from \textit{h1} to \textit{for\_block} and an edge from \textit{for\_block} to \textit{h1}. And when the For loop is over, there will be an edge from \textit{h1} to the \textit{after\_for\_block}. Since there may be nested loops, we use a stack to track the current For loop in order to find the correct block an edge pointing to.

\subsection{Plotting}
After traversing the entire AST, graphviz is used to plot the CFG. CFG is represented by a DiGraph object in graphviz. Using a set to record the visited nodes, we can build a directed graph from the starting basic block and avoid duplication.
\end{document}
