\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{commath}
\usepackage{subfig}
\usepackage{float}
\usepackage{listings}
\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.5}

\title{ECE653 Project Report}
\author{Tiankai Jiang \and Steven Qin \and Huijie Chu}
\date{\today}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\makeatletter
\setlength{\@fptop}{0pt}
\makeatother
\bibliographystyle{ieeetr}
\begin{document}

\maketitle

\begin{abstract}
The main idea of this project is to implement a control graph generator with a foundation build upon the concept of an abstract syntax tree. This report is aimed to help readers better understand the insight of this piece of code with a detailed guild. The introduction session covers a glance at the workflow of this project including a few perspectives on the contribution that the control graph generator may provide. The main part of the algorithms is covered in detail within the implementation session. The project starts off using the python AST package as the parser to identify and parse the input program, which is a piece of read-in code written in python. Processed the code is then stored in the format of an abstract syntax tree, which essentially is an array that contains partitioned statements along with their associated conditions and expressions. The control flow graph is generated by iterate through the processed abstract syntax tree. Graphize is used as the drawing tool to create the final graph representation.
\end{abstract}

\section{Introduction and Overview}\label{section-introduction}
One of the initial purposes of this project is to simplify the time consumption on the preparatory work phase when a new piece of code is handed for understanding. Start by partition a program into an independent or a few aggregated functions. Feed aggregated function bundles respectively into the control graph generator enable readers to visualize the flow of each function, along with their internal logical conditions, statements, and expressions. A control flow graph is a graphical representation that consolidates statements as notation, split and link adjacent notations with edges that each epitomize a path with a correlated logical condition that might be traversed through during the execution phase. It refers to the order in which the individual statements, instructions, or function calls of an imperative or functional program are executed or evaluated.

Furthermore, a comprehensive control graph is essential in the phase of error detection. A missing or contradictory logical condition can create a bug that is laborious to fix. Without a thorough understanding and meticulously go through the logical transition in the program, the bug is arduous to trace. Paths on a control graph, along with their statements, instructions, or function calls, are visually represented. Thus, it is straightforward for a tester to go through suspicious paths without being anxious about getting lost in the flow of logic.

\section{Implementation}\label{section-implementation}
\subsection{Preprocessing}

First of all, there is no point to analyze codes with syntax errors. So the first step is to read and compile the source code. Return immediately if the code cannot be compiled.

Most of the informal coding style of the input will not affect the output of ast module since it analyzes the code in a much lower level. 
\begin{lstlisting}
a=1; b = 1; c =\
1
d = [1,
2,
3]
\end{lstlisting}
is treated the same as
\begin{lstlisting}
a = 1
b = 1
c = 1
d = [1, 2, 3]
\end{lstlisting}
In the above example, the spaces between variables and other variables/constants are ignored, the backslash to connect multi-line codes are ignored and the brackets/parentheses that expands multiple lines are ignored. Also, the semicolons that enable multiple statements in one line are omitted.

Also,
\begin{lstlisting}
a = 1 # this is a comment
\end{lstlisting}
is treated the same as
\begin{lstlisting}
a = 1
\end{lstlisting}

However, multiline comments(doc strings), which are quoted by three single quotes or three double quotes are not ignored by python interpreter. They are treated as multi-line string but assigned to nothing. If the source code contains lots of doc strings, the control flow graph will be redundant and confusing. Hence, the second step is to remove the multiline comments. Using python's tokenize module, we only keep a string token if its previous token is not indentation, is not a new line and the token itself is not the first token in a module.

\subsection{AST Nodes}

\subsection{Models}

Class BasicBlock is the basic module to represent each node in the control flow graph. Each basic block contains a unique block id, two lists of block id to represent its previous and its next blocks, a list to store the functions that are called in this block and a list to store the statements in this block.

To generate a unique block id for each new block and to avoid using global variables, a singleton class BlockId is used. The singleton class will keep track of the blockid. Each time a new block id is to generated, the same BlockId instance is called.

Class CFG is the high level representation of a control flow graph and every function def in the input code will be an individual CFG. The CFG class keeps track of every blocks in the graph using a dictionary: blockid -$>$ basicblock. It also keeps track of every edges in the graph using a dictionary: (fromID, toID) -$>$ condition of the edge. Finally, it contains another dictionary to keep track of function calls in a function: function name -$>$ CFG.

Class CFGVisiter, which subclasses ast.NodeVisitor, is the main part of this project. According to the documentation of ast, ast.NodeVisitor is meant to be subclassed and we can define custom visit methods in the subclass. For example, if an ast node is of type $If$, its custom visit method should be defined in method $visit_If$. And if there is no customized visit method for a certain kind of node, it will be visited using $generic\_visit$ method. Below is the implementation of those custom visiting method.

\subsection{visit\_*}
\end{document}
